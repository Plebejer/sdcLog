---
title: "Introduction to sdcLog"
output:
    rmarkdown::html_vignette:
        toc: true
        toc_depth: 5
        number_sections: false

vignette: >
  %\VignetteIndexEntry{sdcLog}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(knitr.kable.NA = "")
options(sdc.info_level = 1L)
options(datatable.print.keys = FALSE)
options(datatable.print.class = FALSE)

#library(sdcLog)
library(devtools)
load_all()
library(knitr)
library(skimr)
```

# Overview
This vignette introduces the sdcLog package and its main functions, illustrated with various examples. The sdcLog package provides tools which simplify statistical disclosure control in the context of research data centres (RDC).

The package includes three main functions:

* `sdc_descriptives()`: This function is used for statistical disclosure control of descriptive statistics. It checks the data used for the calculation of descriptive statistics for compliance with the rules and regulations set by the RDC. 

    The calculation of simple extreme values such as minimum and maximum is usually not allowed according to RDC rules, so `sdc_descriptives()` cannot be used to check them. Extreme values can only be used if they were calculated with `sdc_extreme()`. 

* `sdc_model()`: This function is used for statistical disclosure control for various types of models. It checks the calculated model and the underlying data for compliance with the rules and regulations of the RDC.

* `sdc_extreme()`: This function is used for the automatic calculation (if possible) of extreme values according to the rules of the research data centre. It uses the available data and calculates the values for desired variables and groupings in compliance with the rules. The values are calculated as averages of a sufficient number of observations. This helps the researcher to easily follow the rules and simplifies the output control.

# sdc_descriptives()
This function performs statistical disclosure control according to two main criteria: On the one hand, it checks for a sufficiently large number of different statistical entities. On the other hand, it checks for dominance, which means that two entities must not account for more than 85 percent of the observed values. How to use `sdc_descriptives()` is shown below.

## Data
To introduce `sdc_descriptives()`, a simple toy dataset is used. There are 20 observations of 10 distinct entities from two different sectors and values in the years 2019 and 2020 for the variables `val_1` and `val_2`.

```{r test_data_descriptives}
data("sdc_descriptives_DT")
sdc_descriptives_DT
```

## Examples
### Simple cases
Consider the case that the mean for `val_1`
<!-- and `val_2`  -->
has been calculated and is now to be output as a result:^[Since sdcLog heavily relies on `data.table`, all examples will use `data.table` syntax as well.]
```{r descriptives_simple_case}
sdc_descriptives_DT[, .(mean = mean(val_1, na.rm = TRUE))]
```

Before this result can be released, it must be checked whether all RDC rules for calculating these values have been followed. Thus, the underlying data is checked for compliance with the RDC rules. 
<!-- The following examples serve to illustrate the examination of these different cases. -->

This is the simplest case, the descriptive statistic (mean) was calculated for the variable `val_1` without further specifications. Required arguments of `sdc_descriptives()` are the data set (`data`), the ID variable (`id_var`) and the variable for which the statistics were calculated (`val_var`):

```{r descriptives_simple}
sdc_descriptives(data = sdc_descriptives_DT, id_var = "id", val_var = "val_1")
```

Since there are no problems at this point, the function runs without warnings and returns (invisibly) a list of information containing options, settings and the checked criteria `distinct_ids` and `dominance`.

Options and settings are always printed to show that all specifications are set according to RDC rules. From the output above follows that there are at least 5 distinct entities required (`sdc.n_ids: 5`) and that dominance is defined as 2 entities (`sdc.n_ids_dominance: 2`) with a value share of more than 85 percent (`sdc.share_dominance: 0.85`). This reflects the standard values for the options. For details on setting options see the [separate vignette on options](options.html).

The settings show again which arguments were specified in the function call and vary depending on the `sdc_function`. This is important if the result from `sdc_descriptives()` is not printed right away.

<!-- Depending on the specification of option `sdc.info_level` variously detailed information are printed to the console. Here the default value (sdc.info_level = 1) is used, therefore only a message appears that the output complies to the rules. On the whole, there are no rule violations and the output of the results could be allowed in this case. -->

### Grouped descriptive statistics using by
In this and the following section some advanced cases are presented to introduce more arguments and functionalities of `sdc_descriptives()`.

In this case the descriptive statistics for the variable `val_1` are grouped by `sector`:
```{r descriptives_by_case}
sdc_descriptives_DT[, .(mean = mean(val_1, na.rm = TRUE)), by = "sector"]
```
<!-- To check this type of result we introduce the `by` argument in `sdc_descriptives()`.  -->
The mean is computed grouped by sector, so the grouping variable must be specified in `by`. Checking the results leads to the following:
```{r, descriptives_by}
sdc_descriptives(data = sdc_descriptives_DT, id_var = "id", val_var = "val_1", by = "sector")
```

The grouped descriptive statistics by sector do not generate a warning and therefore comply with RDC rules. Therefore, the results could be released in this case.

In order to extend this case even further, it is now proposed to group the mean of `val_1` not only by `sector`, but also additionally by `year`:
```{r descriptives_byby_case}
sdc_descriptives_DT[, .(mean = mean(val_1, na.rm = TRUE)), by = c("sector", "year")]
```

To check this result for compliance with RDC rules, use:
```{r descriptives_byby}
sdc_descriptives(data = sdc_descriptives_DT, id_var = "id", val_var = "val_1",
                 by = c("sector", "year"))
```

Now several warnings appear, as both criteria are violated. For sector 1 (`S1`) there are not enough distinct ids in year 2019, as there is a missing value in the data. The dominance criterion for year 2020 is violated in both sectors. As can be seen in the table displayed, the value share of approx. 88 for `S1` (and respectively 91 for `S2`) percent is above the 85 percent limit. Therefore, the descriptive statistics for `val_1`, grouped by `sector` and `year` cannot be released.

### Handling zeros using zero_as_NA
In this case descriptive statistics grouped by sector and year were calculated for variable `val_2`:
```{r descriptives_zero_case}
sdc_descriptives_DT[, .(mean = mean(val_2, na.rm = TRUE)), by = c("sector", "year")]
```
The compliance with the rules can be checked just as in the previous case (only replacing `val_1` by `val_2`):
```{r descriptives_zero}
sdc_descriptives(data = sdc_descriptives_DT, id_var = "id", val_var = "val_2", 
                 by = c("sector", "year"))
```
The result indicates that problems exist and the output does not comply to the rules. There are not enough distinct entities and the output cannot be released like this.

An additional message indicates that the value `0` occurs frequently in the data. This is an indication that `0` is seen as a missing value here and will be recognized and treated as such.

It might be the case that it is accurate according to the data basis to treat values of `0` as `0` (instead of `NA`). Then, specifying the argument `zero_as_NA = FALSE` circumvents the default behaviour and treats `0` like other numeric values:
```{r descriptives_zerozero}
sdc_descriptives(data = sdc_descriptives_DT, id_var = "id", val_var = "val_2", 
                 by = c("sector", "year"), zero_as_NA = FALSE)
```

Now `0` is not recognized as `NA` anymore. In this case the criterion of distinct entities is not longer violated. Therefore, the output could be released (assuming it is actually correct to treat `0`s as usual numeric values).


# sdc_model()
This function checks if your model complies to RDC rules. The criteria of distinct entities and dominance are also checked here. In addition, when using dummy variables, it is checked whether there are enough different entities for each attribute/value level. The function can be used to check a broad range of models like `lm`, `glm` and various others (anything which can be handled by `broom::augment()`; for a list of supported models see `?generics::augment`).

## Data & models
To introduce `sdc_model()`, another dataset with different variables is used, which include dummy-variables.

We have 80 observations of 10 different entities for the variables `y`, `x_1`, `x_2`, `x_3`, `x_4` and additional information on sector, year and country (dummy variables). A summary of the data set is given below. 

```{r model_data}
data("sdc_model_DT")
print(skim(sdc_model_DT))
```

Various simple linear models are specified from this dataset for illustration purposes.

```{r model_models}
model_1 <- lm(y ~ x_1 + x_2, data = sdc_model_DT)
model_2 <- lm(y ~ x_1 + x_2 + x_3, data = sdc_model_DT)
model_3 <- lm(y ~ x_1 + x_2 + x_4, data = sdc_model_DT)
model_4 <- lm(y ~ x_1 + x_2 + dummy_1 + dummy_2, data = sdc_model_DT)
model_5 <- lm(y ~ x_1 + x_2 + dummy_3, data = sdc_model_DT)
```

## Examples
<!-- The previously specified models are now checked for compliance with the rules of the RDC. It is checked, if there are enough distinct entities in the whole model and each model variable is checked if there are problems with dominance. Also every dummy variable is checked for compliance with the rules. -->

A pre-selection of problematic and unproblematic models has been made to better explain the differences. To check for compliance, the model object (`model`), the data used (`data`) and the ID variable (`id_var`) must be specified in `sdc_model()`.

### Simple cases
A check of `model_1` and `model_4` is shown below.

```{r model_simple}
sdc_model(data = sdc_model_DT, model = model_1, id_var = "id")

sdc_model(data = sdc_model_DT, model = model_4, id_var = "id")
```

As we see, there are no problems and the models could be released as output.

### Problematic cases
Now we turn to the problematic cases. We start with checking `model_2` and `model_3`:
```{r model_prob1}
sdc_model(data = sdc_model_DT, model = model_2, id_var = "id")

sdc_model(data = sdc_model_DT, model = model_3, id_var = "id")

sdc_model(data = sdc_model_DT, model = model_5, id_var = "id")
```

Some difficulties occur with these models, but which? 

`model_2` leads to problems with the number of distinct entities. This problem arises with the inclusion of variable `x_3` due to a high number of `NA`s.

In `model_3` there are problems with dominance for variable `x_4`. Thus, according to the RDC rules, these models cannot be released.

For `model_5` the problem stems from a small number of distinct entities for the value level `FR` of `dummy_3`. Therefore this model cannot be released either. Please note that this last case is probably the most common problem to occur when checking models.

# sdc_extreme()
This function automatically calculates extreme values that comply with the rules of the RDC. Again, it mainly checks the criteria of distinct entities and dominance. The values are calculated as averages of a sufficiently large number of observations. It is based on an iterative procedure that aggregates data until there are enough distinct entities to calculate the extreme values and no problems with dominance occur.

The function always starts the iteration process with the lowest possible number of observations for each extreme value (here `5`, since at least five distinct statistical units must be included in the calculation according to the rules of the RDC). Furthermore, the function checks that the subsets of data for minimum and maximum do not overlap.

If there are no problems with the calculation, the function returns a list with the extreme values. Maximum and minimum are always output together, none of the two can be calculated separately. If it is not possible to calculate extreme values under these criteria, a corresponding message is printed and the result is filled with `NA`.

## Data
To introduce `sdc_extreme()`, another simple dataset is used. We have 20 observations of 10 different entities, for which the corresponding sector is given and values for the variables `val_1`, `val_2`, `val_3` in the years 2019 and 2020, respectively.

```{r test_data_extreme}
data("sdc_extreme_DT")
sdc_extreme_DT
```

## Examples
### Simple cases
<!-- For application, the extreme values are calculated for various variables and the special features of the function are demonstrated.  -->
In this simple case, extreme values should be calculated for variable `val_1`. This can be done with `sdc_extreme()` by specifying the dataset (`data`), the id variable (`id_var`) and the variable for which extreme values are to be calculated (`val_var`).
```{r extreme_simple}
sdc_extreme(data = sdc_extreme_DT, id_var = "id", val_var = "val_1")
```
Since no problems occur, the function (invisibly) returns a list with the options, settings and extreme values and prints the calculated extreme values. As shown in the output, the extreme values could be calculated and 5 observations were used for each value. Thus, no additional observations had to be included in the calculation.

<!-- ### Advanced cases -->
<!-- In this section some advanced cases are presented to introduce more arguments and functionalities of the function `sdc_extreme()`. -->

### Specifying the number of values included in minimum and maximum using n_min and n_max
In this case extreme values are to be calculated for variable `val_2`:
```{r extreme_n1}
sdc_extreme(data = sdc_extreme_DT, id_var = "id", val_var = "val_2")
```
If we look at the output, we see that 5 observations were used to calculate the minimum and 7 observations to calculate the maximum. This is because the dominance criterion would be violated if only 5 observations were considered for the maximum. Thus 7 observations are automatically taken into account.

If you prefer to include an equal number of observations per extreme value, it is possible to specify this using the arguments `n_min` and `n_max`. To specify that 7 observations are used for the calculation of the minimum value as well, set `n_min = 7`.

```{r extreme_n2}
sdc_extreme(data = sdc_extreme_DT, id_var = "id", val_var = "val_2", n_min = 7)
```
Now the same number of observations are used to calculate the extreme values.

Consider the case in which extreme values are to be calculated for variable `val_3` and exactly 10 observations are to be included in each value. To do so, `n_max = 10` and `n_min = 10` would need to be specified:
```{r extreme_n3}
sdc_extreme(data = sdc_extreme_DT, id_var = "id", val_var = "val_3", n_min = 10, n_max = 10)
```
But now an error occurs and it is pointed out that it is impossible to calculate extreme values in this case. This is because there is a missing value in `val_3`, so the subsets for the calculation of minimum and maximum values would overlap. Therefore, fewer observations per extreme value would have to be used - for example 8 each.
```{r}
sdc_extreme(data = sdc_extreme_DT, id = "id", val_var = "val_3", n_min = 8, n_max = 8)
```

### Extreme values by groups
It is also possible to calculate extreme values by groups. In the following, these are calculated by `year` and `sector`, separately.
```{r exterme_by1}
sdc_extreme(data = sdc_extreme_DT, id_var = "id", val_var = "val_1", by = "year")

sdc_extreme(data = sdc_extreme_DT, id_var = "id", val_var = "val_1", by = "sector")
```
No problems occur, so extreme values are calculated and output for each group.

This can also be done for several grouping variables at once. Therefore, in the following extreme values for variable `val_1` are to be calculated by `year` and `sector`.
```{r extreme_by2}
extreme_vals <- sdc_extreme(data = sdc_extreme_DT, id_var = "id", val_var = "val_1", 
                            by = c("sector", "year"))
```
Now an error occurs, since the RDC rules would be violated for the calculation of these values. For programming purposes, please note that the structure of the resulting `data.table` remains the same (but is filled with `NA`:
```{r extreme_by3}
extreme_vals
```


# sdc_log()
This function serves to create Stata-like log files from R Scripts. The function is called after the other sdc-functions to get the corresponding code into the log file. It can handle single files or a list of files at once.

A character vector containing the path(s) of the R script(s) which should be run must be specified in the function arguments As well as a character vector containing the path(s) of the text file(s) where the log(s) should be stored. Due to additional arguments it is also possible to specify whether to replace already existing log files and whether it is desired to receive warnings and messages from running the 'r_scripts'. 

A simple call of this function could look as follows.
```{r eval = FALSE}
sdc_log(r_scripts = "C:/Beispielprojekt/r_scripts/sdc_log_example.R",
        log_files = "C:/Beispielprojekt/sdc_log/log_file.txt")
```

# Return values
This section explains the return value(s) of `sdc_functions` in more detail. `sdc_descriptives()`, `sdc_extreme()` and `sdc_model()` each return a list containing options and settings as well as additional, function specific information.

Each function returns a list, e.g. for `sdc_descriptives()`:
```{r return_descriptives1}
typeof(sdc_descriptives(data = sdc_descriptives_DT, id_var = "id", val_var = "val_1"))
```

If the object is assigned, only warnings and messages are printed (if they occur at all):
```{r return_descriptives2}
result_sdc_descriptives <- sdc_descriptives(
  data = sdc_descriptives_DT, id_var = "id", val_var = "val_1"
)

result_sdc_descriptives <- sdc_descriptives(
  data = sdc_descriptives_DT, id_var = "id", val_var = "val_1", by = c("sector", "year")
)
```

If the object itself is printed, the user receives the same information that would have been printed directly without assignment. 

```{r return_descriptives3}
result_sdc_descriptives <- sdc_descriptives(data = sdc_descriptives_DT, id_var = "id", val_var = "val_1")

result_sdc_descriptives

sdc_descriptives(data = sdc_descriptives_DT, id_var = "id", val_var = "val_1")
```

There are additional information that vary depending on the function. The
function `sdc_descriptives()` gives, besides settings and options, information
about compliance with RDC rules regarding distinct entities and dominance for
the checked variable. The object is of class `sdc_descriptives` as well as `list`.

```{r return_descriptives4}
result_sdc_descriptives <- sdc_descriptives(data = sdc_descriptives_DT, id_var = "id", val_var = "val_1")

class(result_sdc_descriptives)

result_sdc_descriptives

str(result_sdc_descriptives)
```

The function `sdc_model()` returns, besides settings and options, information about compliance with RDC rules regarding distinct entities and dominance for every variable of the model. The object is of class `sdc_model` as well as `list`.

```{r return_model}
model <- lm(y ~ x_1 + x_2 + dummy_1 + dummy_2, data = sdc_model_DT)

result_sdc_model <- sdc_model(data = sdc_model_DT, model = model, id_var = "id")

class(result_sdc_model)

result_sdc_model

str(result_sdc_model)
```

The function `sdc_extreme()` returns, besides settings and options, a `data.table` with computed extreme values. The object is of class `sdc_extreme` as well as `list`.

```{r return_extreme1}
result_sdc_extreme <- sdc_extreme(data = sdc_extreme_DT, id_var = "id", val_var = "val_1")

class(result_sdc_extreme)

result_sdc_extreme

str(result_sdc_extreme)
```
